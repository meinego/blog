---
title: "1657. Edu 125"
date: 2022-03-23T21:09:25+09:00
slug: ""
math: true
toc: true
keywords: [코드포스, 1657]
description: "코드포스"
tags: ["코드포스"]
draft: false
---
![Screenshot](https://i.imgur.com/pxVfepk.png)

## A. Integer Moves
0 <= x,y <= 50 인 정수 x,y가 주어질 때, (0,0)에서 (x,y)로 이동하려고 한다.  
정수좌표 (a,b)들을 거쳐가며, 이동거리들은 모두 정수가 되어야 할 때
최소 이동횟수를 구하는 문제다.
### 풀이
모든 (x,y) 에 대해 (0,0) -> (0, x) -> (x,y) 와 같은 이동이 가능하므로 답의 상한은 2이다.
(3,4) 와 같이 (0,0)으로부터 거리가 정수인 점들은 1이다.
(0,0) 은 0이다.
### 코드
```c++
#include <bits/stdc++.h>
using namespace std;
#define N 100'000

int n;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n;
    while(n--) {
        int x,y; cin>>x>>y;
        if (x==0 and y==0) {
            cout << 0 << "\n";
            continue;
        }
        double z = hypot(x,y);
        if (z==int(z)) {
            cout << 1 << "\n";
            continue;
        }
        cout << 2<<"\n";
    }

    return 0;
}
```

## B. XY Sequence
\\(n, B, x, y \\)
가 주어질 때, 아래 조건을 만족하는 배열의 원소합의 최댓값을 구하는 문제  

\\(\text{1. } A_0 = 0\\)  
\\(\text{2. } 0 < i \leq n, \text{   } \text{   } \text{  }  
A_i = A_{i-1} + x \textit{ or } A_i = A_{i-1} -y \\)  
\\( \text{3. For all } i, \text{ }\text{ }\text{ } A_i \leq B \\)  

### 풀이
\\( \text{For } 0 < i \leq n \text{, } \\)  
\\(
A_i = \begin{cases}
   A_{i-1}+x &&\text{if } A_{i-1}+x \leq B
   \newline
   A_{i-1}-y &&\text{otherwise}
    \end{cases}
\\)

이전값 + x가 B 이하라면 사용하고 그렇지 않으면 이전값 - y 를 해서 만든 배열이  
원소합이 최대가 된다.

### 코드
```c++
#include <bits/stdc++.h>
using namespace std;
#define N 100'000

int n,b,x,y;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin>>T;
    while (T--) {
        cin>>n>>b>>x>>y;
        vector<int> v(n+1);
        v[0]=0;
        long long sum = 0;
        for (int i=1; i<n+1; ++i) {
            if (v[i-1]+x <= b)
                v[i] = v[i-1]+x;
            else 
                v[i] = v[i-1]-y;
            sum += v[i];
        }
        cout << sum << "\n";
    }

    return 0;
}
```

## C. Bracket Sequence Deletion
( 또는 ) 로 이루어진 문자열에 대해 다음 두 가지 연산을 수행한다.  

\\( \text{1. 접두사 () 를 지운다. }\\)  
\\(\text{2. 접두사 중 가장 짧은 팰린드롬을 지운다. }\\)  

수행한 연산 총 횟수와 남은 문자 수를 구하는 문제다.
### 풀이
\\(\text{ 1. ( 가 오면 항상 ()는 올바른 쌍이며 (( 는 팰린드롬이므로 다음 문자와 함께 지운다.}\\)
\\(\text{ 2. ) 가 오면 다음에 오는 )까지의 문자열이 팰린드롬이므로 )가 나오기까지 문자열을 삭제한다.}\\)
\\(\text{ 3. 문자열이 하나만 남은 경우 더 이상 지울 수 없다. }\\)
\\(\text{ 4. 문자열을 다보면 끝이다. }\\)
### 코드
```c++
#include <bits/stdc++.h>
using namespace std;
#define N 100'000
int acc, rem;
string s;
int n;

void f(int idx) {
    if (idx==n) return;
    if (idx==n-1) {
        rem=1; return;
    }
    if (s[idx]=='(') {
        acc++; return f(idx+2);
    }
    for (int i=idx+1; i<n; ++i) {
        if (s[i]==')') {
            acc++;
            return f(i+1);
        }
    }
    rem=n-idx;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin>>T;
    while (T--) {
        cin>>n;
        acc=0, rem=0;
        cin>>s;
        f(0);
        cout << acc << " " << rem << "\n";
    }

    return 0;
}
```
## D. For Gamers. By Gamers.
\\(
    TODO
\\)
### 풀이
### 코드
```c++
#include <bits/stdc++.h>
using namespace std;
#define N 1'000'000
typedef long long ll;
vector<ll> dp;
int n,m,k;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>k;
    dp.resize(k+1);
    for (int i=0; i<n; ++i) {
        ll c,d,h;cin>>c>>d>>h;
        dp[c] = max(dp[c], d*h);
    }
    for (int c=1; c<=k; ++c) {
        if (dp[c])
            for (int i=1; i*c<=k; ++i)
                dp[i*c] = max(dp[i*c], dp[c]*i);
    }
    for (int i=1; i<dp.size(); ++i) {
        dp[i] = max(dp[i-1], dp[i]);
    }

    cin>>m;
    for (int i=0; i<m; ++i) {
        ll d,h; cin>>d>>h;
        auto it = upper_bound(dp.begin(), dp.end(), d*h);
        if (it == dp.end()) cout << "-1 ";
        else cout << it - dp.begin() << " ";
    }

    return 0;
}
```

## E. Star MST
\\(\text{TODO}\\)

## 링크
https://codeforces.com/contest/1657